<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>making a website</title>
    <link rel="stylesheet" href="../styles/style.css">
</head>
<body>
    <header>
        <nav id="navbar">
            <ul>
                <li><a href="../pages/home.html">home</a></li>
                <li><a href="../pages/notes.html">notes</a></li>
                <button class="social-button theme" id="theme-toggle"></button>                
            </ul>
        </nav>
    </header>
    
    <main>
        <article id="post">
            <header>
                <h1>making a website</h1>
                <p class="meta">Posted on <time datetime="2023-11-16">November 16, 2023</time></p>
                <p class="meta">Last updated on <time datetime="2023-11-16">November 17, 2023</time></p>
            </header>
            <section>
                <p> This will be a growing dev-log and possibly a real-time display of mental collapse 
                    as i work on this website.</p>
            </section>
            <section>
                <h2>1. markdown</h2>
                <div id="markdown-content">
                    The first thing I want to implement is some sort of special HTML element that
                    can render code blocks or other markdown formatting. There is a script that does this
                    for us <a href="https://cdn.jsdelivr.net/npm/marked/marked.min.js">here</a>, but I 
                    thought it might be a fun challenge to implement this myself. Obviously, implementing
                    markdown from scratch is not an easy task, so lets start with code blocks
                    enclosed in triple backticks.

                    Here's the start of my 'markdown.js' solution.
                    ```javascript
function parseCodeBlocks(htmlElement) {
    const text = htmlElement.innerHTML;

    const replacedText = text.replace(/\```([\s\S]*?)\```/g, function(match, code) {
        const escapedCode = code.replace(/</g, '&lt;').replace(/>/g, '&gt;');
        return `<pre><code>${escapedCode}</code></pre>`;
    });

    htmlElement.innerHTML = replacedText;
}
                    ```

                    I quickly realized this didn't work when I went to render this page, because the 
                    triple backticks inside the code block were treated as the end of the code block.
                    So, I needed to add the ability to escape backticks. While hacky, this gets the
                    job done:
                
                    ```javascript
function parseCodeBlocks(htmlElement) {
    const text = htmlElement.innerHTML;

    const escapedText = text.replace(/\\\```/g, 'ESCAPED_BACKTICKS');

    const replacedText = escapedText.replace(/\```([\s\S]*?)\```/g, function(match, code) {
        const unescapedCode = code.replace(/ESCAPED_BACKTICKS/g, '\```');
        const escapedCode = unescapedCode.replace(/</g, '&lt;').replace(/>/g, '&gt;');
        return `<pre><code>${escapedCode}</code></pre>`;
    });

    htmlElement.innerHTML = replacedText.replace(/ESCAPED_BACKTICKS/g, '\```');
}
                    ```
                    I'm using a simple regular expression to find all instances of '\`\`\`', replacing
                    them with `ESCAPED_BACKTICKS`, rendering the HTML, then replacing 
                    `ESCAPED_BACKTICKS` back with '\`\`\`' at the end. The only problem now is that
                    whenever I write 'ESCAPED_BACKTICKS', it gets replaced by triple backticks!
                    So, we need a way to make sure that originally written 'ESCAPED_BACKTICKS' will
                    be left alone. This was wayyy trickier than I anticipated:
                    ```javascript
function parseCodeBlocks(htmlElement) {
    let text = htmlElement.innerHTML;
    let result = '';
    let inCodeBlock = false;
    let i = 0;

    while (i < text.length) {
        if (text.substring(i, i + 4) === '\\```') {
            result += '\```'; 
            i += 4; 
            continue;
        }
        if (text.substring(i, i + 3) === '\```') {
            inCodeBlock = !inCodeBlock;
            result += inCodeBlock ? '<pre><code>' : '</code></pre>';
            i += 3;
            continue;
        }
        result += text[i]
        i++;
    }

    htmlElement.innerHTML = result;
}
                    ```
                    
                    Here, we parse the text sequentially. When we come across triple backticks that
                    are not escaped, open the code block, and make sure to treat special characters
                    like '<' and '>' properly. LikeI omitted part of this for brevity; when inside a code block 
                    (that is, if `inCodeBlock` evaluates to true), convert &lt; and &gt; to &amp;lt; and &amp;gt;. 
                    This is to prevent HTML tags from being evaluated inside code blocks.
                    <br>
                    <br>
                    This made me think: this should be very easy to extend to in-line code as well, and it was!
                    Just a couple new cases to check, and a special inline styling class for our CSS:
                    ```javascript
function parseCodeBlocksAndInline(htmlElement) {
    // Existing variables...

    let inInlineCode = false;

    while (i < text.length) {
        // Existing cases...

        if (!inCodeBlock && text.substring(i, i + 2) === '\\`') {
            result += '`'; 
            i += 2;
            continue;
        }
        if (!inCodeBlock && text[i] === '`') {
            inInlineCode = !inInlineCode;
            result += inInlineCode ? '<code class="inline-code">' : '</code>';
            i++;
            continue;
        }
    }

    // Unchanged...
}
                    ```
                    A final thing that I want to do for this is add some
                    basic syntax coloring. Of course, we can use the widely used highlight.js 
                    <a href="https://highlightjs.org/">here</a>, but that's no fun.
                    <br>
                    <br>
                    At an extremely basic level, this honestly wasn't too bad to do, especially 
                    since we know that all code blocks are going to be in a code tag. GPT-4 sped 
                    this up tremendously by writing the regex... it easily saved me half an hour here. 
                    It was also tremendous help in generating comprehensive keyword lists which can 
                    be seen in the source code
                    <a href="https://github.com/jehlp/jehlp.github.io/blob/main/scripts/markdown.js">here</a>. 

```javascript
function colorCodeBlocksJS(codeBlock) {
    let codeText = codeBlock.textContent;

    codeText = codeText
        .replace(/(["'])(?:(?=(\\?))\2.)*?\1/g, '<span class="string">$&</span>');

    const segments = codeText.split(/(<span class="string">.*?<\/span>)/);
        
    const value_regex = /\b(true|false|null|undefined)\b/g;
    const number_regex = /\d+/g;
    const single_line_comment_regex = /(?:^|\s)\/\/.*/g;
    const multi_line_comment_regex = /\/\*[\s\S]*?\*\//g;
    const construct_regex = new RegExp(`\\b(${constructs.join('|')})\\b`, 'g');
    const function_regex = new RegExp(`\\b(${builtins.join('|')})\\b`, 'g');
    // Other regex here...
    
    for (let i = 0; i < segments.length; i++) {
        if (!segments[i].startsWith('<span class="string">')) {
            segments[i] = segments[i]
                .replace(construct_regex, '<span class="construct">$1</span>')
                .replace(function_regex, '<span class="function">$1</span>')
                .replace(dom_function_regex, '<span class="function">$1</span>')
                // Other regex here...
        }
    }

    codeText = segments.join('');
    codeBlock.innerHTML = codeText;
}
                    ``` 
                    Like above, I omitted small parts of the pre-processing code, such as properly handling 
                    &lt; and &gt; signs and language selection, but this snippet is honestly enough 
                    for extremely comprehensive syntax highlighting. It's also worth noting that the order 
                    we insert the spans does matter; strings take precedence; for example, "function" 
                    (surrounded by quotes) should be colored as a string, not a built-in. The only 
                    glaring issue is that keywords still get colored inside comments,
                    but that is for another time.
                </div>
            </section>
            <section>
                <h2>2. dark/light mode</h2>
                <div id="markdown-content">
                    I'm usually a dark-mode kind of guy, but I don't think I'm particularly
                    consistent on what color schemas I use on what sites and so on. But here,
                    I've made the tyrannical executive decision to make dark the default. So 
                    naturally I'll probably end up doing more styling for it, and leave light
                    mode a little lagging behind. That being said, this is something that needs
                    to be implemented. 
                    <br>
                    <br>
                    For now, I picked out two images I found online for buttons, and wrote a small 
                    `theme.js` script to change the CSS and swap between the images as needed.

                    ```javascript
function applyTheme() {
    const theme = localStorage.getItem('theme') || 'dark';
    if (theme === 'light') {
        document.documentElement.classList.add('light-mode');
    } else {
        document.documentElement.classList.remove('light-mode');
    }
}

function toggleTheme() {
    const themeToggleBtn = document.getElementById('theme-toggle');
    if (themeToggleBtn) {
        themeToggleBtn.addEventListener('click', () => {
            document.documentElement.classList.toggle('light-mode');
            const theme = document.documentElement.classList
                .contains('light-mode') ? 'light' : 'dark';
            localStorage.setItem('theme', theme);
        });
    }
}
                    ```
                </div>
            </section>
        </article>
    </main>
    
    <script src="../scripts/control.js"></script>
    <script src="../scripts/markdown.js"></script>
    <script src="../scripts/theme.js"></script>
</body>

<footer>
    <p>&copy; 2023 jw.</p>
</footer>

</html>