<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>making a website</title>
    <link rel="stylesheet" href="../styles/style.css">
</head>
<body>
    <header>
        <nav id="navbar">
            <ul>
                <li><a href="../pages/home.html">home</a></li>
                <li><a href="../pages/notes.html">notes</a></li>
                <li id="theme-toggle">Light Mode</li>
            </ul>
        </nav>
    </header>
    
    <main>
        <article id="post">
            <header>
                <h1>making a website</h1>
                <p class="meta">Posted on <time datetime="2023-11-16">November 16, 2023</time></p>
                <p class="meta">Last updated on <time datetime="2023-11-16">November 16, 2023</time></p>
            </header>
            <section>
                <p> This will be a growing dev-log and possibly a real-time display of mental collapse 
                    as i work on this website.</p>
            </section>
            <section>
                <h2>1. markdown</h2>
                <div id="markdown-content">
                    The first thing I want to implement is some sort of special HTML element that
                    can render code blocks or other markdown formatting. There is a script that does this
                    for us <a href="https://cdn.jsdelivr.net/npm/marked/marked.min.js">here</a>, but I 
                    thought it might be a fun challenge to implement this myself. Obviously, implementing
                    markdown from scratch is not an easy task, so lets start with code blocks
                    enclosed in triple backticks.

                    Here's the start of my 'markdown.js' solution.
                    ```javascript
function parseCodeBlocks(htmlElement) {
    const text = htmlElement.innerHTML;

    const replacedText = text.replace(/\```([\s\S]*?)\```/g, function(match, code) {
        const escapedCode = code.replace(/</g, '&lt;').replace(/>/g, '&gt;');
        return `<pre><code>${escapedCode}</code></pre>`;
    });

    htmlElement.innerHTML = replacedText;
}
                    ```

                    I quickly realized this didn't work when I went to render this page, because the 
                    triple backticks inside the code block were treated as the end of the code block.
                    So, I needed to add the ability to escape backticks. While hacky, this gets the
                    job done:
                
                    ```javascript
function parseCodeBlocks(htmlElement) {
    const text = htmlElement.innerHTML;

    const escapedText = text.replace(/\\\```/g, 'ESCAPED_BACKTICKS');

    const replacedText = escapedText.replace(/\```([\s\S]*?)\```/g, function(match, code) {
        const unescapedCode = code.replace(/ESCAPED_BACKTICKS/g, '\```');
        const escapedCode = unescapedCode.replace(/</g, '&lt;').replace(/>/g, '&gt;');
        return `<pre><code>${escapedCode}</code></pre>`;
    });

    htmlElement.innerHTML = replacedText.replace(/ESCAPED_BACKTICKS/g, '\```');
}
                    ```
                    I'm using a simple regular expression to find all instances of '\\```', replacing
                    them with the phrase ESCAPED_BACKTICKS, rendering the HTML, then replacing 
                    ESCAPED_BACKTICKS back with '\\```' at the end. The only problem now is that
                    whenever I write 'ESCAPED_BACKTICKS', it gets replaced by triple backticks!
                    So, we need a way to make sure that originally written 'ESCAPED_BACKTICKS' will
                    be left alone. This was wayyy trickier than I anticipated:
                    ```javascript
function parseCodeBlocks(htmlElement) {
    let text = htmlElement.innerHTML;
    let result = '';
    let inCodeBlock = false;
    let i = 0;

    while (i < text.length) {
        if (text.substring(i, i + 4) === '\\\```') {
            result += '\```'; 
            i += 4; 
            continue;
        }

        if (text.substring(i, i + 3) === '\```') {
            inCodeBlock = !inCodeBlock;
            result += inCodeBlock ? '<pre><code>' : '</code></pre>';
            i += 3;
            continue;
        }

        if (inCodeBlock) {
            if (text[i] === '<') {
                result += '&amp;lt;';
            } else if (text[i] === '>') {
                result += '&amp;gt;';
            } else {
                result += text[i];
            }
        } else {
            result += text[i];
        }

        i++;
    }

    htmlElement.innerHTML = result;
}
                    ```
                    Here, we parse the text sequentially. When we come across triple backticks that
                    are not escaped, open the code block, and make sure to treat special characters
                    like '<' and '>' properly. A final thing that I want to do for this is add some
                    basic syntax coloring. Of course, we can use the widely used highlight.js 
                    <a href="https://highlightjs.org/">here</a>, but that's no fun.
                    <br>
                    <br>
                    At an extremely basic level, this honestly wasn't too bad to do, especially 
                    since we know that all code blocks are going to be in a code tag. GPT-4 sped 
                    this up tremendously by writing the regex... it easily saved me half an hour here.
                    ```javascript
function colorCodeBlocksJS(codeBlock) {
    const js_keywords = [
        'var', 
        'let', 
        'const', 
        'function', 
        'return', 
        'if', 
        'else', 
        'replace', 
        'substring', 
        'continue',
        'startsWith',
        'RegExp',
        'split',
        'length',
        'break',
        'trim',
        'for',
        'join',
        'switch',
        'case',
        'default',
        'new'
    ];

    let codeText = codeBlock.textContent; 

    codeText = codeText
        .replace(/</g, '&lt;').replace(/>/g, '&gt;')
        .replace(/(["'])(?:(?=(\\?))\2.)*?\1/g, '<span class="string">$&</span>');

    const segments = codeText.split(/(<span class="string">.*?<\/span>)/);
    const segment_regex = new RegExp(`\\b(${js_keywords.join('|')})\\b`, 'g');

    for (let i = 0; i < segments.length; i++) {
        if (!segments[i].startsWith('<span class="string">')) {
            segments[i] = segments[i]
                .replace(segment_regex, '<span class="keyword">$1</span>');
        }
    }

    codeText = segments.join('');

    codeText = codeText
        .replace(/\b(true|false|null|undefined)\b/g, '<span class="constant">$1</span>')
        .replace(/\d+/g, '<span class="constant">$&</span>');

    codeBlock.innerHTML = codeText;
}
                    ``` 
                    Of course, this only colors keywords, constants, and strings, but it's
                    better than nothing. It's also worth noting that the order we insert the 
                    spans does matter; strings take precedence, as, for example, "function"
                    (surrounded by quotes) should be colored as a string, not a keyword. I 
                    didn't implement operators because the text is littered with HTML tags;
                    parsing inequalities and equal signs is going to be a mess if I get
                    around to it. 
                </div>
            </section>
            <section>
                <h2>2. dark/light mode</h2>
                <div id="markdown-content">
                    I'm usually a dark-mode kind of guy, but I don't think I'm particularly
                    consistent on what color schemas I use on what sites and so on. But here,
                    I've made the tyrannical executive decision to make dark the default. So 
                    naturally I'll probably end up doing more styling for it, and leave light
                    mode a little lagging behind. That being said, this is something that needs
                    to be implemented. 
                    <br>
                    <br>
                    I'm admittedly terrible at styling, so for now I've decided I dont want to 
                    bother with making a button (and pick out .svgs for sun and moon 
                    icons...) so light and dark mode will be a toggle in the navbar. 

                    ```javascript
function toggleTheme() {
    const themeToggle = document.getElementById('theme-toggle');
    if (themeToggle) {
        themeToggle.addEventListener('click', () => {
            document.documentElement.classList.toggle('light-mode');
            const theme = document.documentElement.classList
                .contains('light-mode') ? 'light' : 'dark';
            localStorage.setItem('theme', theme);
            themeToggle.textContent = theme === 'dark' ? 'Light Mode' : 'Dark Mode';
        });
    }
}
                    ```
                    Unfortunately, even though I <i>thought</i> I was only loading the theme after
                    all the DOM elements are loaded, I guess something else is going wrong because 
                    often I notice a FOUC (Flash Of Unstyled Content). Another item on the todo list, it seems... 
                </div>
            </section>
        </article>
    </main>
    
    <script src="../scripts/control.js"></script>
    <script src="../scripts/markdown.js"></script>
    <script src="../scripts/theme.js"></script>
</body>

<footer>
    <p>&copy; 2023 jw.</p>
</footer>

</html>